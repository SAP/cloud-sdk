---
id: service-binding-destination-loader
title: The ServiceBindingDestinationLoader API
hide_title: false
hide_table_of_contents: false
sidebar_label: ServiceBindingDestinationLoader
description: This article dives into the ServiceBindingDestinationLoader API, explaining important implementation details and how to customize it.
keywords:
  - sap
  - cloud
  - sdk
  - destination
  - servicebinding
  - servicebindingdestinationloader
  - java
  - connectivity
  - btp
---

# The `ServiceBindingDestinationLoader` API

The `ServiceBindingDestinationLoader` API is part of the [`cloudplatform-connectivity` artifact](https://search.maven.org/artifact/com.sap.cloud.sdk.cloudplatform/cloudplatform-connectivity) and can be used to convert [Service Bindings](https://github.com/SAP/btp-environment-variable-access/wiki/Fundamentals#service-binding) into `HttpDestination` instances.

The following example demonstrates how to use the API:

```java
import com.sap.cloud.environment.servicebinding.api.ServiceIdentifier;

var options = ServiceBindingDestinationOptions.forService(ServiceIdentifier.DESTINATION).build();
HttpDestination destination = ServiceBindingDestinationLoader.defaultLoaderChain().getDestination(options);
```

## How It Works

In general, the `ServiceBindingDestinationLoader` API is designed very similarly to [the `DestinationLoader` API](destination-accessor#about-the-destinationloader-api):

Each `ServiceBindingDestinationLoader` implementation is supposed to provide the transformation logic for one specific "type" of `ServiceBinding`. <br />
The SAP Cloud SDK provides, for example, [an implementation that is capable of dealing with service bindings that use OAuth2 authentication](#about-the-oauth2servicebindingdestinationloader).

In contrast to the `DestinationLoader` API, however, the `ServiceBindingDestinationLoader` API requires more sophisticated input, namely [the `ServiceBindingDestinationOptions`](#about-the-options).
This class is designed to hold all information that is required to transform a `ServiceBinding` into an `HttpDestination` - this, first and foremost, includes the `ServiceBinding` itself.

Furthermore, there is also a [_chain_ implementation](#about-the-chain-implementation) (compare [the `DestinationLoaderChain`](destination-accessor#about-the-destinationloaderchain)) that can be used to combine multiple `ServiceBindingDestinationLoader` implementations into one.
Hereby, the chain will try to load a destination using the given `ServiceBindingDestinationLoader` delegates until the first of them succeeds - much like a fallback mechanism.
This concept is also reflected in the example from above, where the `defaultLoaderChain` is used to load a destination.

## About the _Options_

The `ServiceBindingDestinationOptions` is an **extensible and type-safe** collection of parameters that can be used to configure the `ServiceBinding` to `HttpDestination` transformation process.
Hereby, the least information that is needed is the `ServiceBinding` itself, which can be provided using the `ServiceBindingDestinationOptions.forService(ServiceBinding)` method.

Alternatively, you can also use `ServiceBindingDestinationOptions.forService(ServiceIdentifier)`.
This method will try to find a `ServiceBinding` for the given `ServiceIdentifier` using the [`DefaultServiceBindingAccessor` instance](https://github.com/SAP/btp-environment-variable-access/blob/main/api-parent/access-api/src/main/java/com/sap/cloud/environment/servicebinding/api/DefaultServiceBindingAccessor.java).

#### Caution

If there are multiple or no `ServiceBinding`s for the given `ServiceIdentifier`, an exception will be thrown.

Besides the `ServiceBinding`, there is a second parameter that is shared between all `ServiceBindingDestinationLoader` implementations: The `OnBehalfOf`, for which the destination should be loaded.
This can be set using the `onBehalfOf` method. <br />
If not explicitly specified, `OnBehalfOf.TECHNICAL_USER_CURRENT_TENANT` is used.

### Custom Parameters

Adding custom parameters to the `ServiceBindingDestinationOptions` can be done using the `withOption(OptionsEnhancer)` method.
Hereby, an `OptionsEnhancer` is a type-safe way of adding arbitrary parameters to the `ServiceBindingDestinationOptions`.

The type-safety is implemented by, internally, storing the parameters in a `Map` that is keyed by the `Class` of the parameter's type.
Using generics, the `ServiceBindingDestinationOptions.getOption(Class)` method can guarantee that the returned value is of the requested type. <br />
Furthermore, using the `Class` as the key for the internal `Map` ensures that there cannot be any parameter clashes.

<details>
<summary>Example</summary>

Lets assume we are providing a custom `ServiceBindingDestinationLoader` implementation that requires some additional information to be able to transform a `ServiceBinding` into an `HttpDestination`.

In this example, we assume that there are two different APIs for our service.
Depending on which API we want to create our `HttpDestination` for, we need to slightly alter the transformation logic.
Additionally, we want to be able to supply an additional HTTP header value that should be added to the `HttpDestination`.

To achieve this behavior, we would need to implement two `OptionsEnhancer`s like so:

```java
enum MyApiChoice implements ServiceBindingDestinationOptions.OptionsEnhancer<MyApiChoice> {
    API1,
    API2;

    @Nonnull
    @Override
    public MyApiChoice getValue() {
        return this;
    }
}

class MyHttpHeader implements ServiceBindingDestinationOptions.OptionsEnhancer<String> {
    private final String value;

    public static MyHttpHeader of(String value) {
        return new MyHttpHeader(value);
    }

    private MyHttpHeader(String value) {
        this.value = value;
    }

    @Nonnull
    @Override
    public String getValue() {
        return value;
    }
}
```

The first implementation uses an `enum` to implement a **fixed set of choices** option.
It is noteworthy that the actual parameter type is the `MyApiChoice` enum itself.
That way, we will be able to retrieve the set value later on.

In contrast to that, the second implementation provides a `String` parameter.

Setting the options can then be done like so:

```java
ServiceBinding someServiceBinding;

ServiceBindingDestinationOptions
        .forService(someServiceBinding)
        .withOption(MyApiChoice.API1)
        .withOption(MyHttpHeader.of("some-value"))
        .build();
```

Finally, we can retrieve and use the set values like so:

```java
ServiceBindingDestinationOptions options;
Option<MyApiChoice> maybeOption = options.getOption(MyApiChoice.class);
if (maybeOption.isEmpty()) {
    return; // we are not handling this transformation
}

Option<String> maybeHeaderValue = options.getOption(MyHttpHeader.class);

MyApiChoice option = maybeOption.get();
switch (option) {
    case API1:
        // do something
        break;
    case API2:
        // do something else
        break;
}
```

</details>

## About the _OAuth2Loader_

The `OAuth2ServiceBindingDestinationLoader` comes as part of the [`connectivity-oauth` artifact](https://search.maven.org/artifact/com.sap.cloud.sdk.cloudplatform/connectivity-oauth) and provides a customizable implementation for converting `ServiceBinding`s that use OAuth2 authentication into `HttpDestination` instances. <br />
More precisely, it supports the **OAuth2 Client Credentials** and **OAuth2 Client Certificate** grant types.

Internally, the implementation performs the following steps:
1. Check whether the given `ServiceBindingDestinationOptions` can be transformed (e.g. whether the `ServiceBinding` uses a supported grant type).
2. Extract the required information from the `ServiceBinding` (i.e. the service URL, the token URL, and the client identity).
3. Check whether the `ServiceBindingDestinationOptions` contain another `HttpDestination` that should be _proxied_.
    1. If so, create a new `HttpDestination` that points to the _destination to be proxied_ and uses the authentication information provided in the given `ServiceBinding` for the **proxy authentication** (i.e. HTTP header `Proxy-Authorization`).
    2. If not, create a new `HttpDestination` that points to the service URL and uses the authentication information provided in the `ServiceBinding` (i.e. HTTP header `Authorization`).

### Dealing With Arbitrary Service Bindings

Even though **service bindings** are a fundamental concept in the SAP Business Technology Platform, the way they are used and structured can **vary greatly from service to service**.
As a consequence, it is not possible to provide a uniform way of dealing with arbitrary `ServiceBinding`s. <br />
Therefore, the `OAuth2ServiceBindingDestinationLoader` leverages the `OAuth2PropertySupplier` interface to extract the required information from a given `ServiceBindingDestinationLoaderOptions` instance.

The `OAuth2ServiceBindingDestinationLoader` stores a **static list** of `OAuth2PropertySupplier` instances.
Whenever the `OAuth2ServiceBindingDestinationLoader` is asked to load a destination, it will iterate over this list (**in order**) to see whether
1. the given `ServiceBindingDestinationOptions` can be transformed into an `HttpDestination` using the current `OAuth2PropertySupplier` instance, and, if so
2. extract the required information from the given `ServiceBindingDestinationOptions` using the current `OAuth2PropertySupplier`.

This approach should look familar as it is effectively a fallback mechanism, once again.

By default, the SAP Cloud SDK pre-configures the `OAuth2ServiceBindingDestinationLoader` so that is able to deal with `ServiceBinding`s for the following BTP services:
* [The BTP Destination Service on Cloud Foundry](https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/overview)
* [The BTP Connectivity Service on Cloud Foundry](https://help.sap.com/docs/connectivity/sap-btp-connectivity-cf/what-is-sap-btp-connectivity)
* [The SAP Workflow Service on Cloud Foundry](https://api.sap.com/package/SAPCPWorkflowAPIs/all)
    * [Inbox API (OData)](https://api.sap.com/api/SAP_CP_Workflow_TCM_CF/overview)
    * [Workflow API (REST)](https://api.sap.com/api/SAP_CP_Workflow_CF/overview)
* [The SAP Business Rules Service on Cloud Foundry](https://api.sap.com/package/SAPCPBusinessRulesAPIs/all)
    * [Rule Authoring API](https://api.sap.com/api/SAP_CF_BusinessRules_Repository/overview)
    * [Rule Execution API (v2)](https://api.sap.com/api/SAP_CF_BusinessRules_Runtime_V2/overview)
* The _SAP Business Logging on Cloud Foundry_ (SAP internal)
  * Configuration API
  * Text API
  * Reading API
  * Writing API

#### Caution

For BTP services that offer different APIs (such as the Workflow service), make sure to define which API the converted `HttpDestination` should point to using the corresponding `BtpServiceOptions`. <br />
For example:

```java
import com.sap.cloud.sdk.cloudplatform.connectivity.BtpServiceOptions;

ServiceBindingDestinationOptions
        .forService(ServiceIdentifier.WORKFLOW)
        .withOption(BtpServiceOptions.WorkflowOptions.REST_API)
        .build();
```

### Customization

In case the default configuration of the `OAuth2ServiceBindingDestinationLoader` does not fit your needs, you can customize it by adding your own `OAuth2PropertySupplier` instances to the static list of the `OAuth2ServiceBindingDestinationLoader`:

```java
OAuth2ServiceBindingDestinationLoader.registerPropertySupplier(this::canBeConverted, this::propertySupplierFactory);

boolean canBeConverted(ServiceBindingDestinationOptions options);
OAuth2PropertySupplier propertySupplierFactory(ServiceBindingDestinationOptions options);
```

As shown above, the `registerPropertySupplier` method takes two methods as parameters.
This might be unintuitive, but is needed to allow for efficient implementations.

What is happening internally when this method is used, is that the given parameters are transformed into an internal representation, which is then **prepended** to the list of available `OAuth2PropertySupplier` instances.
In other words: Using the `registerPropertySupplier` method will make your `OAuth2PropertySupplier` instance be considered **before** any previously registered `OAuth2PropertySupplier` instance, including the default ones.

<details>
<summary>Full Example</summary>

To make things a bit more concrete, let's assume we wanted to implement support for an other service, which uses it's very own `ServiceBinding` structure.

Lets assume our service produces service bindings that look like this:
```json
{
    "service": "my-service",
    "credentials": {
        "service": {
          "uri": "https://my-service.com"
        },
        "oauth": {
            "uri": "https://my-service.com/oauth/token",
            "id": "my-client-id",
            "secret": "my-client-secret"
        }
    }
}
```

To support this service, we would need to implement an `OAuth2PropertySupplier` that is capable of extracting the required information from this structure:

```java showLineNumbers="true"
class MyServiceOAuth2PropertySupplier extends DefaultOAuth2PropertySupplier
{
    public MyServiceOAuth2PropertySupplier(ServiceBindingDestinationOptions options) {
        super(options, Collections.singletonList("oauth"));
    }

    @Override
    public boolean isOAuth2Binding() {
        return getOAuthCredential(String.class, "id").isDefined();
    }

    @Nonnull
    @Override
    public URI getServiceUri() {
        return getCredentialOrThrow(URI.class, "service", "uri");
    }

    @Nonnull
    @Override
    public URI getTokenUri() {
        return getOAuthCredentialOrThrow(URI.class, "uri");
    }

    @Nonnull
    @Override
    public ClientIdentity getClientIdentity() {
        var clientId = getOAuthCredentialOrThrow(String.class, "id");
        var clientSecret = getOAuthCredentialOrThrow(String.class, "secret");
        return new ClientCredentials(clientId, clientSecret);
    }
}
```

Lets examine the implementation above:

Right in the first line, you can see that our implementation extends the `DefaultOAuth2PropertySupplier` class, instead of implementing the `OAuth2PropertySupplier` interface directly. <br />
This is because the `DefaultOAuth2PropertySupplier` class provides a lot of useful functionality, which we can reuse in our implementation. <br />
We will see that in a second.

Next thing we should pay attention to is the constructor of our class. <br />
It takes an instance of `ServiceBindingDestinationOptions` as a parameter.
This instance is then passed to the `super` constructor (line 4) along with a list of `String`s.

The super class (`DefaultOAuth2PropertySupplier`) uses these parameters to 
1. cache the _credentials_ portion of the `ServiceBinding` (given in the `ServiceBindingDestinationOptions`) as a [`TypedMapView` instance](https://github.com/SAP/btp-environment-variable-access/blob/main/api-parent/consumption-api/src/main/java/com/sap/cloud/environment/servicebinding/api/TypedMapView.java) and
2. set the _default oauth2 properties path_ **within** the _credentials_ portion of the `ServiceBinding`.

Converting the _credentials_ portion of the `ServiceBinding` into a `TypedMapView` is helpful for parsing the nested structure. <br />
Therefore, it is a good idea to do the conversion (i.e. `TypeMapView.ofCredentials(ServiceBinding)`) just once as it performs an expensive deep-copy.
Hereby, the `DefaultOAuth2PropertySupplier` takes care of doing the conversion upon initialization and caching the result for later use.

Further down in our code (i.e. within the overriden methods), we can then use the `getCredential/OrThrow` and `getOAuthCredential/OrThrow` methods to extract the required information from the cached _credentials_. <br />
The main difference between `getCredential` and `getOAuthCredential` is that the latter will **prepend** the _default oauth2 properties path_ to the one given in the method invocation before trying to extract the information. <br />
In our example (line 9), this means that `getOAuthCredential(String.class, "id")` will try to extract a `String` value from `credentials.get("oauth").get("id")` (_pseudo code_). <br />
In contrast to that, using just `getCredential(String.class, "id")` would try to extract a `String` value from `credentials.get("id")` (_pseudo code_). <br />
`getOAuthCredential` is therefore just a neat shortcut that can help to reduce repetitive code.

Lastly, we need to register our `OAuth2PropertySupplier` implementation with the `OAuth2ServiceBindingDestinationLoader`:

```java
class MyServiceOAuth2PropertySupplier extends DefaultOAuth2PropertySupplier {
    private static final ServiceIdentifier MY_SERVICE_IDENTIFIER = ServiceIdentifier.of("my-service");

    public static boolean matches(ServiceBindingDestinationOptions options) {
        var serviceIdentifier = options.getServiceBinding().getServiceIdentifier().orElse(null);
        return MY_SERVICE_IDENTIFIER.equals(serviceIdentifier);
    }

    // skipped for brevity
}

OAuth2ServiceBindingDestinationLoader.registerPropertySupplier(MyServiceOAuth2PropertySupplier::matches, MyServiceOAuth2PropertySupplier::new);
```

In the above example, we added a static `matches` method to our `OAuth2PropertySupplier` implementation, which we can use to check whether the given `ServiceBindingDestinationOptions` can be transformed into an `HttpDestination` using our implementation.
We are then using method references to register our implementation with the `OAuth2ServiceBindingDestinationLoader`.

</details>

## About the Chain Implementation

As mentioned [above](#how-it-works), the `ServiceBindingDestinationLoader` comes with a private _chain_ implementation that works very similar to [the `DestinationLoaderChain`](destination-accessor#about-the-destinationloaderchain).

The default instance of that chain (`ServiceBindingDestinationLoader.defaultLoaderChain`) is created using the _Service Locator Pattern_ to find all available `ServiceBindingDestinationLoader` implementations on the classpath.
Instances of these implementations are then used as delegate loaders.
When transforming a `ServiceBindingDestinationOptions` into an `HttpDestination`, the chain will invoke the delegates **in order** until the first one either succeeds or throws an exception other than `DestinationNotFoundException`.

#### Caution

The _Service Locator Pattern_ does not provide any guarantees about the order in which implementations on the classpath are found.
Therefore, it is **crucial** that `ServiceBindingDestinationLoader` implementations do **not handle the same `ServiceBindingDestinationOptions`** as otherwise the default chain's behavior would be **unpredictable**. <br />
Implementations provided by the SAP Cloud SDK follow this rule.

### Custom Chain Instances

If the [guarantee mentioned above](#caution) does not hold, you can create your own chain instance:

```java
ServiceBindingDestinationLoader myChain = ServiceBindingDestinationLoader.newLoaderChain(
        Arrays.asList(
                new MyFirstLoader(), 
                new MySecondLoader()
        ));
```

The code above initializes a new instance of the private chain implementation, which uses the given `ServiceBindingDestinationLoader` instances **in the specified order** as its delegates.
Therefore, deterministic behavior is guaranteed.