---
id: middleware
title: Middleware
sidebar_label: Middleware
description: How the SAP Cloud SDK behaviour is adjusted using middlewares.
keywords:
  - sap
  - cloud
  - sdk
  - JavaScript
  - TypeScript
  - resilience
  - middleware
---

import ThemedImage from '@theme/ThemedImage';
import useBaseUrl from '@docusaurus/useBaseUrl';

## Concept

The main purpose of the SAP Cloud SDK is to execute asynchronous HTTP requests.
This can either happen via a generated [OData](./odata/execute-request#setting-middlewares) or [OpenAPI](./openapi/execute-request#setting-middlewares) client or the [http client](./connectivity/http-client#setting-middlewares).
Either way, the final result after fetching destinations and doing various other things is an [axios](https://github.com/axios/axios) request.
Sometimes you want to adjust the way the SAP Cloud SDK executes the axios request.

The middleware adds a very flexible way to add custom functionality to the request execution.
You can add multiple layers of middleware to adjust requests to your needs.

```ts
executeHttpRequest(
  { url: 'http://example.com' },
  {
    middleware: [middleware1, middleware2,...],
    method: 'get'
  }
);
```

The API for a middleware is as follows:

```ts
export type MiddlewareFunction = (
  request: HttpRequest
) => Promise<HttpResponse>;

export type Middleware = (options: MiddlewareOptions) => MiddlewareFunction;

export interface MiddlewareOptions {
  fn: MiddlewareFunction;
  context: HttpMiddlewareContext;
  skipNext: () => void;
}
```

Every middleware needs to return a `MiddlewareFunction` instance which has the same parameters and return type as the input function `fn()`.
Let's investigate the different properties of the `MiddlewareOptions` interface:

- The `fn()` function is the returned function from the previous middleware.
  For the first one it is the original HTTP request from the SAP Cloud SDK.
- The `context` provides information on the request like URL, headers and HTTP method.
- The `skipNext` will exit all following middlewares

Note that a middleware should **not** execute the function but construct and return a `MiddlewareFunction`.
This makes a chain of middlewares different from a pipeline where the functions are executed one after another.
This may seem abstract now, but the example in the next section will bring some concreteness to the topic.

## Example Hello World

A middleware logs "Hello World" and leaves the original function unchanged.

```ts
const helloWorldMiddleware = options => {
  console.log('hello world');
  return options.fn;
};
```

Note that the log statement is executed when the middleware is added and not when the function executes.
If you want to trigger the log on function execution you have to create a new function in the middleware.
Remember that a middleware must **not** execute the original function.
It adds functionality to the function and creates a new function from it.

```ts
const helloWorldMiddleware = options => {
  return request => {
    console.log('hello world');
    options.fn(request);
  };
};

const helloWorldMiddlewareWrong = options => {
  //This would execute the function while the middlewares are added - Do NOT do this.
  const responseRunning = options.fn(options.context.fnArgument);
  return request => responseRunning;
};
```

In the example the custom code executes before the function `fn()`.
This will result in a stack like behaviour for multiple middlewares.
For a queue like behaviour, add the code after the function resolves:

```ts
const helloWorldMiddleware = options => {
  return request => {
    options.fn(request).then(response => {
      console.log('hello world');
      return response;
    });
  };
};
```

## Example Multiple Middlewares

A good practice is to define reusable, single-purpose middlewares.
You can add multiple of those middlewares to combine the effects.
Assume you want to modify your call to have a timeout and use a fallback.
The implementation of these middlewares could look like this:

```ts
const timeoutMiddleware = options => {
  return request => Promise.race([options.fn(request), timeoutPromise]);
};

const fallbackMiddleware = options => {
  return request => {
    try {
      return options.fn(request);
    } catch (e) {
      //implement some fallback logic
    }
  };
};
```

Multiple middlewares are added one-by-one to the request.
The order is from left to right in the array.

```ts
executeHttpRequest(
  { url: 'http://example.com' },
  {
    middleware: [timeoutMiddleware, fallbackMiddleware],
    method: 'get'
  }
);
```

The initial function is a `GET` request to `http://example.com`.
The first middleware creates a new function adding a timeout to the HTTP request (see _h<sub>1</sub>_ in the picture below).
The second middleware adds a fallback to this new function leading _h<sub>2</sub>_ in the picture below.

The middlewares in this example are implemented like a stack.
The fallback was added last, so it will execute first.
It acts on the HTTP request with the timeout (_h<sub>1</sub>_ in the picture below).
The timeout counts only the time for the actual execution of the original function _f<sub>0</sub>_.

<ThemedImage
  alt="Middleware execution order"
  sources={{
    light: useBaseUrl('img/middleware_light.svg'),
    dark: useBaseUrl('img/middleware_dark.svg')
  }}
  className="center"
  width="100%"
/>

If you switched the order of the middlewares:

```ts
executeHttpRequest(
  { url: 'http://example.com' },
  {
    middleware: [fallback, timeout],
    method: 'get'
  }
);
```

The timout would apply to the time for the original request plus additional time for a potential fallback call (see _g<sub>1</sub>_ and _g<sub>2</sub>_ in the picture above).
From this example, you see that the order of middlewares is crucial.

The provided default resilience middlewares should be added in the following order:

1. timeout
2. circuit breaker
3. retry.
   The SAP Cloud SDK provides default resilience middlewares so that you do not have to worry about the details in most cases.
   You can find detailed information on the resilience topic in a [dedicated documentation](../guides/resilience).

## Example Middleware Context

The previous examples did not use the middleware context.
However, the context provides useful information you can use in your middleware.

```ts
export interface HttpMiddlewareContext {
  readonly tenantId: string;
  readonly uri: string;
  readonly jwt?: string;
  readonly destinationName?: string;
  fnArgument: ArgumentT;
}
```

The fallback middleware could consider the uri:

```ts
const fallbackMiddleware = options => {
  return (request: HttpRequest) => {
    try {
      return options.fn(request);
    } catch (e) {
      if (options.context.uri === 'http://system-one.com') {
        //do something
      } else {
        //do something else
      }
    }
  };
};
```

Note that the `fnArgument` is not marked as `readonly`.
This indicates that changes to this object will change the argument for the actual execution.
The SAP Cloud SDK uses the axios client which has a `timeout` property.
You could set a timeout on client level like this:

```ts
const clientTimeoutMiddleware = options => {
  options.fnArgument.timeout = 500;
  return options.fn;
};
```

## Benefits of Middlewares

You could implement many use cases of middlewares also directly.
You could implement a fallback using a global try/catch.

```ts
try {
  executeHttpRequest(destination, options);
} catch (e) {
  //implement fallback logic
}
```

However, this has two disadvantages:

- The first one is more of cosmetic nature.
  The middlewares encourage you to implement the logic in a separate function which can be reused in different places.
  Your actual business code stays clean.
  This becomes even more obvious for [typed clients](./odata/execute-request) which represent you business requirements more directly.
- The second one is about the position where you can include the code.
  With the middleware you can include logic directly to the HTTP layer.
  This is much more powerful than code on the outer layer.

Assume you want to replace the HTTP client of the SAP Cloud SDK uses with a different one.
Only with a middleware this is possible.
You have to adjust the request so that it matches your client and the response so that it matches the expected form.

```ts
import httpClient from 'some-client-like-node-fetch';

const replaceHttpClientMiddleware = options => {
  return request => {
    const castedRequest = castRequest(options.context.fnArgument);
    return httpClient(castedRequest).then(response => castResponse(response));
  };
};
```
