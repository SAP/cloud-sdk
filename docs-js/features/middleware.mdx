---
id: middleware
title: Middleware
sidebar_label: Middleware
description: How the SAP Cloud SDK behaviour is adjusted using middlewares.
keywords:
  - sap
  - cloud
  - sdk
  - JavaScript
  - TypeScript
  - resilience
  - middleware
---

## Concept

The main purpose of the SAP Cloud SDK is to execute asynchronous HTTP requests.
This can either happen via a generated [OData](./odata/execute-request#setting-middlewares) or [OpenAPI](./openapi/execute-request#setting-middlewares) client or the [http client](./connectivity/http-client#setting-middlewares).
Either way, the final result after fetching destinations and doing various other things is an [axios](https://github.com/axios/axios) request.
Sometimes you want to adjust the way the SAP Cloud SDK executes the axios request.

The middleware adds a very flexible way to add custom functionality to the request execution.
You can add multiple layers of middleware to adjust requests to your needs.

```ts
executeHttpRequest(
  { url: 'http://example.com' },
  {
    middleware: [middleware1, middleware2,...],
    method: 'get'
  }
);
```

The API for a middleware is as follows:

```ts
export type Middleware = (options: MiddlewareOptions) => MiddlewareFunction;

export interface MiddlewareOptions {
  fn: MiddlewareFunction;
  context: HttpMiddlewareContext;
  skipNext: () => void;
}

export type MiddlewareFunction = (
  request: HttpRequest
) => Promise<HttpResponse>;
```

Every middleware needs to return a `MiddlewareFunction` instance which has the same parameters and return type as the input function `fn()`.
Let's investigate the different properties of the `MiddlewareOptions` interface:

- The `fn()` function is the returned function from the previous middleware.
  For the first one it is the original HTTP request from the SAP Cloud SDK.
- The `context` provides information on the request like URL, headers and HTTP method.
- The `skipNext` will exit all following middlewares

This may seem abstract now, but the example in the next section will bring some concreteness to the topic.

## Example Hello World

A middleware logs "Hello World" and leaves the original function unchanged.

```ts
const helloWorld: Middleware = function (options) {
  console.log('hello world');
  return options.fn;
};
```

Note that the log statement is executed when the middleware is added and not when the function executes.
If you want to trigger the log on function execution you have to create a new function in the middleware.

```ts
const helloWorld: Middleware = function (options) {
  return request => {
    console.log('hello world');
    options.fn(request);
  };
};
```

Note that a middleware should **not** execute the original function.
It adds functionality to the function and creates a new function from it.

In the example the custom code executes before the function `fn()`.
This will result in a stack like behaviour for multiple middlewares.
For a queue like behaviour, add the code after the function resolves:

```ts
const helloWorld: Middleware = function (options) {
  return request => {
    options.fn(request).then(response => {
      console.log('hello world');
      return response;
    });
  };
};
```

## Example Multiple Middlewares

A good practice is to define reuseable, single-purpose middlewares.
You can add multiple of those middlewares to combine the effects.
Assume you want to modify your call to have a timeout and use a fallback.
The implementation of these middlewares could look like this:

```ts
const timeout: Middleware = function (options) {
  return request => Promise.race([options.fn(request), timeoutPromise]);
};

const fallback: Middleware = function (options) {
  return request => {
    try {
      return options.fn(request);
    } catch (e) {
      //implement some fallback logic
    }
  };
};
```

Also here the middleware does **not** execute the function but adds functionality.
For the timeout middleware, it is crucial because a timeout must run in parallel to the actual function.
This makes a chain of middlewares different from a pipeline where the functions are executed one after another.

Multiple middlewares are added one-by-one to the request.
The order is from left to right in the array.

```ts
executeHttpRequest(
  { url: 'http://example.com' },
  {
    middleware: [timeout, fallback],
    method: 'get'
  }
);
```

The initial function is a `GET` request to `http://example.com`.
The first middleware adds a timeout to this request leading a new function.
The second middleware adds a fallback to this new function.

The middlewares in this example are implemented like a stack.
The fallback was added last so it will execute first.
It acts on the request with the timeout.
The timeout was added first and counts only the time for the actual execution without the fallback.

If you would use:

```ts
executeHttpRequest(
  { url: 'http://example.com' },
  {
    middleware: [fallback, timeout],
    method: 'get'
  }
);
```

The timout would apply to the time for the original request plus additional time for a potential fallback call.
From this example, you see that the order of middlewares is crucial.

The provided default resilience middlewares should be added in the following order:
1. timeout
2. circuit breaker
3. retry.
The SAP Cloud SDK provides default resilience middlewares so that you do not have to worry about the details in most cases.
You can find detailed information on the resilience topic in a [dedicated documentation](../guides/resilience).

## Example Middleware Context

The previous examples did not use the middleware context.
However, the context provides useful information you can use in your middleware.

```ts
export interface HttpMiddlewareContext {
  readonly tenantId: string;
  readonly uri: string;
  readonly jwt?: string;
  readonly destinationName?: string;
  fnArgument: ArgumentT;
}
```

The fallback middleware could consider the uri:

```ts
const fallback: Middleware = function (options) {
  return (request: HttpRequest) => {
    try {
      return options.fn(request);
    } catch (e) {
      if (options.context.uri === 'http://system-one.com') {
        //do something
      } else {
        //do something else
      }
    }
  };
};
```

Note that the `fnArgument` is not marked as `readonly`.
This indicates that changes to this object will change the argument for the actual execution.
The SAP Cloud SDK uses the axios client which has a `timeout` property.
You could set a timeout on client level like this:

```ts
const httpClientTimeout: Middleware = function (options) {
  options.fnArgument.timeout = 500;
  return options.fn;
};
```

## Benefits of Middlewares

You could implement many use cases of middlewares also directly.
You could implement a fallback using a global try/catch.

```ts
try {
  executeHttpRequest(destination, options);
} catch (e) {
  //implement fallback logic
}
```

However, this has two disadvantages:

- The first one is more of cosmetic nature.
  The middlewares encourage you to implement the logic in a separate function which can be reused in different places.
  Your actual business code stays clean.
  This becomes even more obvious for [typed clients](./odata/execute-request) which represent you business requirements more directly.
- The second one is about the position where you can include the code.
  With the middleware you can include logic directly to the HTTP layer.
  This is much more powerful than code on the outer layer.

Assume you want to replace the HTTP client of the SAP Cloud SDK uses with a different one.
Only with a middleware this is possible.
You have to adjust the request so that it matches your client and the response so that it matches the expected form.

```ts
import httpClient from 'some-client-like-node-fetch';

replaceHttpClient: Middleware = function (options) {
  return request => {
    const castedRequest = castRequest(options.context.fnArgument);
    return httpClient(castedRequest).then(response => castResponse(response));
  };
};
```
