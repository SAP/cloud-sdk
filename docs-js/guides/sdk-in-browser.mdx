---
title: Use the SAP Cloud SDK in the Browser
sidebar_label: Use the SAP Cloud SDK in the Browser
description: You'll learn how to package SDK for a browser, what are the limitations, and how to use it with popular frontend frameworks.
keywords:
  - sap
  - cloud
  - sdk
  - cloud native
  - cloud sdk
  - sap cloud sdk
---

The SAP Cloud SDK for JavaScript can be used both as a backend and frontend library when used in a browser.
Because of the specifics of a browser environment, some features might be unavailable.
To help you get up and running faster in a browser, we'll outline the main steps and caveats of using SAP Cloud SDK on the frontend.
The Angular framework is used to illustrate the usage.

## Prerequisite

You have a frontend application set up.
For example, an [Angular application](https://angular.io/cli/new) via `ng new myProject`.

## Include the SAP Cloud SDK

Most examples use the business partner API.
To learn how to generate an API client from the service definition, refer to [this article](features/odata/generate-odata-client.mdx).

```ts
//In the .html part of the component
<button (click)="callApi()">Click me!</button>

//In the .ts part of the component
import { businessPartnerService } from './generated/business-partner-service';

const { businessPartnerApi } = businessPartnerService();

async function callApi(){
  const result = await businessPartnerApi.requestBuilder().getAll().execute(myDest)
  console.log(result)
}
```

:::note
For the destination lookup, the SAP Cloud SDK relies on Node.js functionality, e.g., `process.env`.
However, the request building, execution, and result parsing do not require any Node.js modules and can be used on the frontend.
Hence, create the destination variable `myDest` manually.
:::

Executing `npm run build` causes compilation errors of the kind "Module not found: Error: Can't resolve 'https' in '".
Check out the [workaround](#workaround) for resolving these kinds of errors.

## Run Locally

As discussed above, the `myDest` can not be fetched via the destination service.
Create and pass the variable when running locally.

```ts
import { Destination } from '@sap-cloud-sdk/connectivity';

const myDest: Destination = {
  url: 'https://my123456.s4hana.ondemand.com',
  username: 'myUser',
  password: 'myPassowrd'
};
```

Executing `npm run serve` compiles the project and hosts the app on a local server.

:::note

All modern browsers block requests triggered from a browser to a remote system to ensure [same origin policy](https://en.wikipedia.org/wiki/Same-origin_policy).
One simple way to overcome this issue locally is to disable the web security of the browser temporarily (e.g. --disable-web-security for Chrome).
Alternatively, create a second localhost proxy server that adds the `access-allow-origin-header` to the request.

:::

## Run on SAP BTP, Cloud Foundry Environment

For productive usage, the methods mentioned above for running locally are not needed.
Configure the `xs-app.json` file of the approuter with an entry as shown below:

```json
{
  "source": "/REMOTE-SYSTEM-IDENTIFIER/(.*)",
  "target": "/$1",
  "destination": "DESTINATION-NAME-ON-CF"
}
```

and then, in the application define the destination as follows:

```ts
import { Destination } from '@sap-cloud-sdk/connectivity';

const myDest: Destination = {
  url: '/REMOTE-SYSTEM-IDENTIFIER'
};
```

The created request to `/REMOTE-SYSTEM-IDENTIFIER/sap/opu/odata/sap/API_BUSINESS_PARTNER/A_BusinessPartner` will be matched by the approuter and the destination with the given URL and credentials is used.

:::note

This approach does not support principal propagation to On-premise systems.
For this, you need a JWT and need to include the proper header fields defining the user.
See the documentation on [On-premise systems](../features/connectivity/on-premise) for details.

:::

:::note

With webpack, it is possible to [load resources](https://webpack.js.org/plugins/normal-module-replacement-plugin/) for local or productive usage.
Using such a switch you can adjust the value of the destination for the two cases.

:::

## Workaround

Webpack version 5 removed the automatic node.js polyfills and they need to be added manually.
An error message during the compilation from TS to JS provides a hint on how to achieve that.

- Add the corresponding library of the core node.js modules in `devDependencies` in your `package.json` file
- Include `@angular-builders/custom-webpack` in `devDependencies`
- Create a custom webpack configuration named `node-webpack.config.js` and list the node modules

```js
module.exports = {
  resolve: {
    alias: {
      process: 'process/browser',
      https: 'agent-base'
    },
    fallback: {
      url: false,
      os: false,
      assert: false,
      constants: false,
      zlib: false,
      path: false,
      http: false,
      util: require.resolve('util/'),
      process: require.resolve('process/browser'),
      stream: require.resolve('stream-browserify'),
      buffer: require.resolve('buffer'),
      crypto: require.resolve('crypto-browserify'),
      https: require.resolve('https-browserify')
    }
  },
  plugins: [new ProvidePlugin({ process: 'process/browser' })]
};
```

- In the `angular.json` file, adjust the `build` target to use the custom builder

```json
 "build": {
   "builder": "@angular-builders/custom-webpack:browser",
   "options": {
     "customWebpackConfig": {
       "path": "./node-webpack.config.js"
     }
   }
  ...
 }
```

- In the `angular.json` file, adjust the `serve` target to use the custom builder as well

```json
 "serve": {
   "builder": "@angular-builders/custom-webpack:dev-server",
```

- In the `package.json` file, exclude the node modules that do not exist in the browser

```json
"browser": {
  "fs": false,
  "net": false,
  "tls": false
}
```

Now, the project should build and run locally.
